.TH 1
.SH sisa16_asm
Macro-enabled Assembler and Disassembler for the sisa16 virtual portable computer architecture.
.SH SYNOPSIS
.B sisa16_asm
.B -i [or -run]
.B -dis
.B -fdis
.IR infilename
.IR location
.B -o 
.IR outfilename
.B [-nc]
.B [--no-comments]
.B [-C]
.B [-E]
.B [-pl]
.B [-v]
.B [-h]
.B [--help]
.B [--version]
.SH DESCRIPTION
.B sisa16_asm
builds and optionally executes SISA16 virtual machine images. for the
.B sisa16
virtual portable computer architecture.

.SH CLI TUTORIAL

Assembling a file:

sisa16_asm -i my_program.asm -o my_program.bin

Assembling and running a file, without creating a bin:

sisa16_asm -run my_program.asm

Displaying compiletime environment information:

sisa16_asm -C

Viewing version information:

sisa16_asm -v

.SH OPTIONS
.BR -i
specifies the imput assembly file. The last input file is used, no others are.

sisa16_asm -i myfile.asm -o myfile.bin

.BR -run
No output file is generated. An emulator built into the assembler is used to immediately execute code, making this an effective scripting language.

sisa16_asm -run myfile.asm

.BR -dis
Specifies a file to disassemble.

sisa16_asm -dis clock.bin 0x20000

will disassemble continuously starting from 0x20000 (the third region) until three halts or illegal opcodes are found.

you can also use --disassemble

.BR -fdis
Specifies a file to disassemble, but does not block on excess illegal opcodes. The entire image is disassembled.

sisa16_asm -fdis clock.bin 0x20000

.BR -o
specifies the output filename.

.BR -nc
Disable comments from disassembly output.

.BR --no-comments
same as -nc

.BR -C
prints the compiletime environment information.

.BR -E
expands all macros and does not write an output file.

.BR -pl
prints all lines to base assembler file-building instructions (bytes)

.SH LANGUAGE
.TP
Terminology:

.B Sisa16

A virtual hardware implementation.

  
It is a standardized instruction set (Standardized BY THIS MANPAGE and the assembler it documents) 
for which you (yes, you, dear reader) can create programs and share with all your friends.

You can think of it like a "virtual computer" on your computer.

.B Sisa16 CPU
The interpreter of the SISA16 ISA which this manpage teaches you how to use.
It could be a hardware implementation, or it could be a software interpreter.

The assembler comes with a built-in emulator.

.B Main Memory
SISA16 programs have sixteen megabytes of byte-addressable memory which it ordinarily operates on.

.B 

.B Instruction:
An opcode telling the Sisa16 CPU what to do.

.B Instruction Operand:
Data immediately following an instruction, which gives it needed information.

.B Address: 
Location where data is stored in main memory.

.B Register: 
CPU variables of a constant size and location.

.B Aligned
Multiple of a number. If something is "16-aligned" it is at an address that is a multiple of sixteen.

A multiple of sixteen, represented as a binary number, has zeroes in its four lowest (bottom) bits.

it is also valid to say "16 byte aligned" which means effectively the same thing.

.B Page: 
256 contiguous bytes that are 256-byte-aligned.

A page's address in hex always ends in two zeroes:

0x100 is the address of a page, which is the bytes from 0x100 to 0x1FF inclusive.

0xAB7900 is the address of a page, including bytes 0xAB7900 to 0xAB79FF inclusive.

0x0 is the address of a page, comprised of the bytes from 0x00 to 0xFF.

0x379 is not the address of a page, but this address is part of page 3, the page whose address is 0x300.

Thus, it could be said that the "page" of 0x379 is 3.

To get the page that an address points to, you divide by 256 decimal, or 0x100 (hex)

.B Region: 
64 kilobytes starting at an address with 2 low bytes equalling zero.

or, to put it in terms of alignment,

65536 bytes which are 65536-aligned.

0x390000 is the address of a region, specifically "region 0x39"

0x10000 is the address of a region, region 1.


0x123406 is not, because the lower four hex-digits "3406" are not zero.

0x0 is a region and that is it its address too, because when fully written out: 

0x000000 

its lowest two bytes are all zeroes.

The "Current Region" is the region where the program counter currently resides, and 

the region where 16-bit addressing mode operations (such as lda, llda, illdb...) operate.

.B Zero 'Home' or 'Stack' Region: 
the topmost region, where the stack pointer is stuck

region 0.

.B Device: 
the implementation of gch(), pch(), di(), dcl(), (and technically the clock instruction) and interrupt() from d.h which is used for I/O,
accessible with getchar, putchar, and interrupt
in the assembly language. 

There are three sample drivers provided.

One of them uses only the C standard library to provide implementations, which means that getchar is blocking.

One of them uses TERMIOS to provide non-blocking getchar.

The last is an A/V device, which provides graphics and sound which is written in SDL2.

It reads the keyboard using SDL2's textinput interface, which is non-blocking.

By default, these are all privileged instructions.

.B Segment:
The additional region of memory outside the normal SISA16 address space, which is
not executable.

.B Privilege:
The sisa16 architecture has two modes of execution: Privileged [0] and User[1].

You boot into Privileged by default. User mode must be entered manually either with emulate, or priv_drop.

After this, a user program begins executing in an entirely separate area of memory from the area of memory
where you start out- an entirely separate sixteen megabytes.

You can think of this as "switching into user mode" or "switching into privileged mode" where applicable.



Some instructions cannot be executed in User mode without returning to the privileged process. they are "Privileged"

.B Thread
A program (series of instructions) stored in memory with its own execution seperate from others.

.B Process

The sisa16 architecture has multiple individual areas of sixteen megabytes for use by separate threads of execution.

These threads do not use true parallelism but rather use multitasking (context switching) and preemption.

As mentioned before, you boot into the privileged mode. This is thread 0, the first thread.

it can do things that the other threads cannot, like interact with the device and read/write
to the other threads' memory.

In order for the other non-privileged threads (which are called tasks) to run, 
the privileged thread (or, privileged process, it is not a task) must call it to run.

By default, all other threads' memory are filled with undefined (usually zero) memory, so it must have been filled
by the privileged process beforehand.

(The Emulate instruction does this automatically, copying the privileged process's memory into a non-privileged
task's memory. This is faster than copying memory manually but for obvious reasons it may be a security risk

in an advanced operating system implementation.)

the non-privileged process will then run for some number of instructions and then an error flag 
is returned to the privileged process.

the privileged process can then use this error flag to respond to the non-privileged process which it ran
to provide services like interrupts, syscalls, and interaction with the device.

alternatively it can decide to never continue the execution of that task ever again, shutdown the computer,
replace that task, or whatever it likes.


.B Task

The non-privileged processes which have their own 16 Megabyte memory maps 
entirely separate from the privileged process.

.B


.SH INSTRUCTIONS

.TP
Supported instructions:

halt- end execution (1 byte) (0)

lda- load byte into register a,zero extend (3 bytes)(1)

la - set register a to value (2 bytes) (2)

ldb - load byte into register b, zero extend (3 bytes)(3)

lb - set register b to value (2 bytes) (4)

sc- load 2 constant bytes into c (3 bytes) (5)

sta- store a to location (3 bytes) (6)

stb- store b to location (3 bytes) (7)

add- a = a + b (1 byte) (8)

sub- a = a - b (1 byte) (9)

mul- a = a * b (1 byte) (A)

div- a = a / b (1 byte) (B)

mod- a = a % b (1 byte) (C)

cmp- if(a<b) a = 0; else if(a>b)a=2; else a=1; (1 byte) (D)

jmpifeq- set program counter to c if a == 1 (1 byte) (E)

jmpifneq- set program counter to c if a is not 1 (1  byte) (F)

getchar- read short from device. (Usually standard out) (1 byte) (PRIVILEGED) (10)

putchar- write register A as short to device (Usually standard out) (1 byte) (PRIVILEGED) (11)

and- a = a & b (1 byte)(12)

or- a = a | b (1 byte)(13)

xor- a = a ^ b (1 byte)(14)

lsh- a <<= b (1 byte)(15)

rsh- a >>= b (1 byte)(16)

ilda- a = read(c), indirectly access memory through register c and load it into a (1 byte)(17)

ildb- b = read(c), indirectly access memory through register c and load it into b (1 byte)(18)

cab- c = a<<8 + b, make c the combination of a and b. (1 byte)(19)

ab- a = b (1 byte)(1A)

ba- b = a (1 byte)(1B)

alc- a = low half of c (1 byte)(1C)

ahc- a = the high half of c (1 byte)(1D)

nop- (1byte) (1E)

cba c = b<<8 + a, make c the other combination of a and b. (1 byte) (1F)

lla, Large Load 2 constant bytes into A (3 bytes)(20)

illda, a = [c], indirectly load 2 bytes into A through C (1 byte)(21)

llb, Large Load 2 constant bytes into B (3 bytes)(22)

illdb b = [c], indirectly load 2 bytes int B through C (1 byte)(23)

illdaa, a = [a] indirectly load 2 bytes into A through A (1 byte)(24)

cpcr, c = program counter region (1 byte)(25)

illdab, a = [b] indirectly load 2 bytes into A through B (1 byte)(26)

illdba, b = [a] indirectly load 2 bytes into B through A (1 byte)(27)

ca c=a (1 byte)(28)

cb c=b (1 byte)(29)

ac a=c (1 byte)(2A)

bc b=c (1 byte)(2B)

ista, [c] = a, (as byte) store a at the location pointed to by C (1 byte)(2C)

istb, [c] = b, (as byte) store b at the location pointed to by C (1 byte)(2D)

istla, [c] = a, (as short) indirectly store large a at the location pointed to by C(1 byte)(2E)

istlb, [c] = b, (as short) indirectly store large b at the location pointed to by C(1 byte)(2F)

jmpc, unconditionally jump to the location pointed to by c. (1 byte) (30)

stla, store large A at constant address (3 bytes) (31)

stlb, store large B at constant address (3 bytes) (32)

stc, store C at constant address (3 bytes) (33)

push, stp+=val, add to the stack pointer by a number of bytes (3 bytes) (34)

pop, stp-=val, subtract from the stack pointer by a number of bytes (3 bytes) (35)

pusha, stp+=a, add a to the stack pointer (1 byte) (36)

popa, stp-=a, sub a from the stack pointer (1 byte) (37)

astp, a = stp (1 byte) (38)

bstp, b = stp (1 byte) (39)

compl, a = ~a (1 byte) (3A)

cpc, c = the program counter. (1 byte) (3B)

call: (1 bytes)(3C)
write the program counter to the stack pointer. Push the stack pointer by 2. Jump to c.

ret: (1 byte)(3D)
subtract 2 from the stack pointer. load the program counter from the stack pointer.

farillda: load short using far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (3E)

faristla: store short into far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (3F)

farilldb: load short using far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (40)

faristlb: store short into far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (41)

NOTE: Page size is 256 bytes.

farpagel: copy 256 bytes from any page indexed by c to page indexed by a (1 byte) (42)

farpagest: copy 256 bytes to any page indexed by c from page indexed by a (1 byte) (43)

lfarpc: pp = a; pc=0; move the program counter offset to a different 64k region of memory. Set PC to 0. (1 byte) (44)

farcall: write the program counter to the stack pointer. 
Push the stack pointer by 2.
Write the program counter offset to the stack pointer. Set the program counter offset to a. Jump to c. (1 byte) (45)

farret: Subtract 1 from the stack pointer, assign the program counter offset from the stack pointer.
subtract 2 from the stack pointer. load the program counter from the stack pointer. (jump)
(1 byte) (46)

farilda: load byte using far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (47)

farista: store byte into far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (48)

farildb: load byte using far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (49)

faristb: store byte into far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (4A)

priv_drop: Drop privilege after returning from emulate, return to user mode. (4B)

	this effectively just invokes EMULATE, but without using the current memory map- the lower one is used.

	The registers are not reset.

user_geta: a = usermode register A. (4C)

user_getb: a = usermode register B. (4D)

user_getc: a = usermode register C. (4E)

user_get0: RX0 = usermode register RX0. (4F)

user_get1: RX0 = usermode register RX1. (50)

user_get2: RX0 = usermode register RX2. (51)

user_get3: RX0 = usermode register RX3. (52)

user_getstp: a = usermode stack pointer. (53)

user_getpc: a = usermode program counter. (54)

user_getr: a = usermode program counter region. (55)

user_farilda: a = user memory[ ((c&255) << 16) + b]. (56)

user_seta: set user mode's A register. (57)

task_set: save a task to the task buffer, using register A to select which task buffer. (58)

task_kill: Resets essential variables for a task so it can be setup for another task's execution. (59)

syscall: make syscall. Generate error code 19. (5A)

alpush: push short register a onto the stack. (1 byte) (5B)

blpush: push short register b onto the stack. (1 byte) (5C)

cpush: push short register c onto the stack. (1 byte) (5D)

apush: push byte register a onto the stack. (1 byte) (5E)

bpush: push byte register b onto the stack. (1 byte) (5F)

alpop: pop short register a from the stack. (1 byte) (60)

blpop: pop short register b from the stack. (1 byte) (61)

cpop: pop short register c from the stack. (1 byte) (62)

apop: pop byte register a from the stack. (1 byte) (63)

bpop: pop byte register b from the stack. (1 byte) (64)

interrupt: pass the registers to the BIOS "interrupt" function (1 byte) (PRIVILEGED) (65)

clock: set register a to the execution time in thousandths of a second. (1 byte) (66)

	Register B will be the time in seconds. 

arx0: load RX0 into A. (1 byte) (67)

brx0: load RX0 into B. (1 byte) (68)

crx0: load RX0 into C. (1 byte) (69)

rx0a: load A into RX0. (1 byte) (6A)

rx0b: load B into RX0. (1 byte) (6B)

rx0c: load C into RX0. (1 byte) (6C)

arx1: load RX1 into A. (1 byte) (6D)

brx1: load RX1 into B. (1 byte) (6E)

crx1: load RX1 into C. (1 byte) (6F)

rx1a: load A into RX1. (1 byte) (70)

rx1b: load B into RX1. (1 byte) (71)

rx1c: load C into RX1. (1 byte) (72)

arx2: load RX2 into A. (1 byte) (73)

brx2: load RX2 into B. (1 byte) (74)

crx2: load RX2 into C. (1 byte) (75)

rx2a: load A into RX2. (1 byte) (76)

rx2b: load B into RX2. (1 byte) (77)

rx2c: load C into RX2. (1 byte) (78)

arx3: load RX3 into A. (1 byte) (79)

brx3: load RX3 into B. (1 byte) (7A)

crx3: load RX3 into C. (1 byte) (7B)

rx3a: load A into RX3. (1 byte) (7C)

rx3b: load B into RX3. (1 byte) (7D)

rx3c: load C into RX3. (1 byte) (7E)

rx0_1: RX0 = RX1; (1 byte) (7F)

rx0_2: RX0 = RX2; (1 byte) (80)

rx0_3: RX0 = RX3; (1 byte) (81)

rx1_0: RX1 = RX0; (1 byte) (82)

rx1_2: RX1 = RX2; (1 byte) (83)

rx1_3: RX1 = RX3; (1 byte) (84)

rx2_0: RX2 = RX0; (1 byte) (85)

rx2_1: RX2 = RX1; (1 byte) (86)

rx2_3: RX2 = RX3; (1 byte) (87)

rx3_0: RX3 = RX0; (1 byte) (88)

rx3_1: RX3 = RX1; (1 byte) (89)

rx3_2: RX3 = RX2; (1 byte) (8A)

lrx0: load 4 constant bytes (highest, high, low, lowest) into RX0. (5 bytes) (8B)

lrx1: load 4 constant bytes (highest, high, low, lowest) into RX1. (5 bytes) (8C)

lrx2: load 4 constant bytes (highest, high, low, lowest) into RX2. (5 bytes) (8D)

lrx3: load 4 constant bytes (highest, high, low, lowest) into RX3. (5 bytes) (8E)

farildrx0: load RX0 from memory location M[(c&255)<<16 + a] (1 byte) (8F)

farildrx1: load RX1 from memory location M[(c&255)<<16 + a] (1 byte) (90)

farildrx2: load RX2 from memory location M[(c&255)<<16 + a] (1 byte) (91)

farildrx3: load RX3 from memory location M[(c&255)<<16 + a] (1 byte) (92)

faristrx0: store RX0 at memory location M[(c&255)<<16 + a] (1 byte) (93)

faristrx1: store RX1 at memory location M[(c&255)<<16 + a] (1 byte) (94)

faristrx2: store RX2 at memory location M[(c&255)<<16 + a] (1 byte) (95)

faristrx3: store RX3 at memory location M[(c&255)<<16 + a] (1 byte) (96)

rxadd: RX0 += RX1;(1 byte) (97)

rxsub: RX0 -= RX1;(1 byte) (98)

rxmul: RX0 *= RX1;(1 byte) (99)

rxdiv: RX0 /= RX1;(1 byte) (9A)

rxmod: RX0 %= RX1;(1 byte) (9B)

rxrsh: RX0 >>= RX1;(1 byte) (9C)

rxlsh: RX0 <<= RX1;(1 byte) (9D)

rx0push: push 32 bit RX0 register onto the stack. (1 byte) (9E)

rx1push: push 32 bit RX1 register onto the stack. (1 byte) (9F)

rx2push: push 32 bit RX2 register onto the stack. (1 byte) (A0)

rx3push: push 32 bit RX3 register onto the stack. (1 byte) (A1)

rx0pop: pop 32 bit RX0 register from the stack. (1 byte) (A2)

rx1pop: pop 32 bit RX1 register from the stack. (1 byte) (A3)

rx2pop: pop 32 bit RX2 register from the stack. (1 byte) (A4)

rx3pop: pop 32 bit RX3 register from the stack. (1 byte) (A5)

rxand: RX0 &= RX1(1 byte) (A6)

rxor: RX0 |= RX1(1 byte) (A7)

rxxor: RX0 ^= RX1(1 byte) (bitwise XOR) (A8)

rxcompl: RX0 = ~RX0; bitwise inversion, 1's complement.(1 byte) (A9)

rxcmp:	if(RX0<RX1)a=0;else if(RX0>RX1)a=2;else a=1;  (1 byte) (AA)

seg_ld: load segment RX1 into page RX0 of Main Memory. (1 byte) (AB)

seg_st: store segment RX0 from main memory into page RX1 in the segment. (1 byte) (AC)

seg_config: Set the segment access offset and mask, from RX0 and RX1, respectively. (PRIVILEGED) (1 byte) (AD) 

This should be set with care,

invalid values cause undefined behavior. It is configured by default to only allow safe memory accesses.

an offset equal to the return value of seg_pages means that segment access is disabled.


fltadd: floating point addition, RX0 += RX1, disabled with -DNO_FP (1 byte) (AE)

fltsub: (1 byte) (AF)

fltmul: (1 byte) (B0)

fltdiv: divide by zero is erroneous. (1 byte) (B1)

fltcmp: if(RX0<RX1)a=0;else if(RX0>RX1)a=2;else a=1;, but RX0 and RX1 are treated as floating point (1 byte) (B2)

seg_pages: get the number of pages in the segment in RX0. (1 byte) (B3)

ildrx0_1: indirectly load rx0 by using rx1. (1 byte) (B4)

ildrx0_0: indirectly load rx0 by using rx0. (1 byte) (B5)

farjmprx0: jump to location pointed to by rx0. (1 byte) (B6)

istrx0_1: store rx0 at the location pointed to by rx1. (1 byte) (B7)

istrx1_0: store rx1 at the location pointed to by rx0. (1 byte) (B8)

cbrx0: c = RX0>>16; b = RX0 & 0xffFF; (1 byte) (B9)

carx0: c = RX0>>16; a = RX0 & 0xffFF; (1 byte) (BA)

rxidiv: RX0 = (signed)RX0 / (signed)RX1 (1 byte) (BB)

rximod: RX0 = (signed)RX0 % (signed)RX1 (1 byte) (BC)

farldrx0: load RX0 from constant memory location (4 bytes) (BD)

farldrx1: (4 bytes) (BE)

farldrx2: (4 bytes) (BF)

farldrx3: (4 bytes) (C0)

farllda: (4 bytes) (C1)

farlldb: (4 bytes) (C2)

farldc: (4 bytes) (C3)

farstrx0: store rx0 to constant memory location (4 bytes) (C4)

farstrx1: (4 bytes) (C5)

farstrx2: (4 bytes) (C6)

farstrx3: (4 bytes) (C7)

farstla: (4 bytes) (C8)

farstlb: (4 bytes) (C9)

farstc: (4 bytes) (CA)

aincr: A += 1 (1 byte) (CB)

adecr: A -= 1 (1 byte) (CC)

rxincr: RX0 += 1 (as unsigned value) (1 byte) (CD)

rxdecr: RX0 -= 1 (as unsigned value) (1 byte) (CE)

emulate: Run a SISA16 sandboxed machine. (1 byte) (PRIVILEGED) (CF)

	This machine will execute at a lower privilege level than the current machine and is pre-emptively executed for

	an implementation defined amount of time. the return value in A

	will be 255 if the user process has been preempted, otherwise it will be zero for normal termination, or an error code.

	You may use this error code to provide services to the machine, such as privileged instructions!

	Error code 16 is generated by getchar, 17 for putchar, and 18 for interrupt. 19 for syscall.

	15 is generated for a general privilege failure.

	Both the privileged and user registers are saved in context switches. Emulate will save all privileged registers,

	and when it returns, the user's registers are also saved.

rxitof: convert RX0 from signed int to float. (1 byte) (D0)

rxftoi: convert RX0 from float to signed int. (1 byte) (D1)

seg_getconfig: Get the segment's configuration.  (D2)

rxicmp: comparison like rxcmp, but for signed 32 bit integers. (1 byte) (D3)

logor: logical and, a = a || b (1 byte) (D4)

logand: logical and, a = a && b (1 byte) (D5)

boolify: make a into boolean, a = (a != 0) (D6)

nota: make a into inverse boolean, a = (a == 0) (D7)

user_farista: store a to user memory location ((c & 255)<<16)+b  (D8)

task_ric: If pre-emption is enabled, reset the current task's instruction counter to zero. (PRIVILEGED) (D9)

	NOTE: this should only be used if there is a single process. if there is more than one process,

	you should write a routine that calculates how many cycles should be allotted to each

	process per second.

user_farpagel: load user page c into privileged page a (PRIVILEGED) (DA)

user_farpagest: store privileged page a into user page c (PRIVILEGED) (DB)

llda: load 16 bit value into a from fixed memory location. (DC)

lldb: load 16 bit value into b from fixed memory location. (DD)

ldrx0: load 32 bit value from fixed memory location. (DE)

ldrx1: load 32 bit value from fixed memory location. (DF)

ldrx2: load 32 bit value from fixed memory location. (E0)

ldrx3: load 32 bit value from fixed memory location. (E1)

ldc: load 16 bit value into c from fixed memory location. (E2)

strx0: store RX0 to fixed memory location. (E3)

strx1: store RX1 to fixed memory location. (E4)

strx2: store RX2 to fixed memory location. (E5)

strx3: store RX3 to fixed memory location. (E6)

fcall: do farcall to immediate address. (E7)

lcall: do region-lcoal call to immediate address. (E8)

jne: branch to immediate address if a is not 1. (E9)

jeq: branch to immediate address if a is 1. (EA)

jim: jump to immediate address (EB)

task_sic: set task preemption instruction counter (EC)

	Using a small value in your operating system implementation causes

	frequent returns to your kernel, but using a large value

	allows programs to hang the machine.

user_farjmp: move user's program counter and program counter region to position in RX0. (ED)

	The active task's PCR will be set to RX0>>16.

	the active task's PC will be set to RX0 & 0xffFF.

	this is intended to write drivers for a kernel

farlda: load single byte from fixed far memory location to a (EE)

farldb: load single byte from fixed far memory location to b (EF)

farsta: store byte a to immediate far memory location (F0)

farstb: store byte b to immediate far memory location (F1)

The last 14 opcodes are halt duplicates, free for expansion (1 byte)

.TP
.B Comments
comment lines are lines that begin with // or #.

You can also include comments on most lines by typing `//` on the line.`

Escaped newlines allow a comment after the backslash.
backslash slash slash in your source code escaped the newline but also allows a comment.

.TP
.B Labels

Labels are just macros that contain only a number indicating a location in the code.

VAR#myLabel#@

is one way of doing a label. However, you can also do a label like this:

asm_label\\myLabel;

which can be done inline with your code.

":myLabel:"

is explicit syntactic sugar for the same.


You can also do:

"myLabel:"


"myLabel: la 1; lfarpc;"

this will be tranformed under syntactic sugar rules to

"asm_label\\myLabel; la 1; lfarpc"

It's the same for the following:

":myLabel: la 1; lfarpc;"

Note that due to it being possible to do both ":myLabel:" and "myLabel:" there are possibly ambiguous situations.



VAR#myMacro#la 1; ret;

myMacro:bad_label:halt;



this will be parsed such that it's trying to declare "myMacro" as a new label, even though it already exists.

To solve this, put a space in:

myMacro :bad_label:halt;


.TP
.B Macros

Macros are defined with VAR# lines.

VAR#myMacro#myMacroExpansion

everything after the second # is part of the macro.

Only @ is evaluated during macro definition time.

You can define a macro if it was not already defined, by putting a questionmark in front of its name:

VAR#?myMacro#defaultvalue

this allows you to give macros a "default value".

if these two lines follow sequentially in a source file:

VAR#LIBRARY_REGION#12

VAR#?LIBRARY_REGION#2

they will define LIBRARY_REGION to be 12, not 2.

.TP
.B Macros with Arguments

It is possible to pass arguments into a macro.

You define your macro as normal, but then you use it with square brackets surrounding it,
and a sequence of curly brace pairs afterward.

Try this simple example:

.myMacFunc:asm_arg0;asm_arg1

//asm_print;


//[myMacFunc]{asm_arg0;}{wj};bytes 3;asm_stop;

[myMacFunc]{[myMacFunc]{bytes 0}{bytes 1}}{[myMacFunc]{bytes 3}{bytes 4}};asm_print

Beware of how they behave with evaluation sequence points (|).

They can be used to implement fairly cheap structured programming.

Structured programming in an assembly language? WOW!

.TP
.B asm_label\\

Through an incredible series of bad hack-jobs, I have managed to implement a system whereby a custom label
can be inline with parsing.



asm_label\\myLabel;

The backslash immediately after the word "label" is absolutely necessary to prevent the macro
from being expanded on the second pass of the MACRO_EXPANSION stage. It is part of the directive name.

Ordinary macro definition rules apply.


.TP
.B Auto generated names

By using ASM_GEN_NAME in your source code, you can get the assembler to automatically generate a name for you.


.TP
.B $||, the single logical line operator

By using $|| you can force the assembler to interpret multiple lines as a single logical line.

simply surround the lines you want to force the assembler to interpret this way, and you're done!

.TP
.B ${ and $}

Creating a line with ${ at the beginning. initiates a "function scope"

you can declare variables on this line with a C-esque syntax.

you can even declare variables that are "arguments" to the function passed on the stack.

${(int a, int b)uint*f[30];

creates a farcall function scope which allocates 30 * 4 bytes on the stack.

note that function arguments are assumed to be stack-passed, not register, and the function argument
order on the stack is reversed, namely, the last function argument

is the one deepest on the stack.

if you need a local function (call, not farcall) then you put an "l" before the function argument list:

${l(int a, int b)uint*f[30];

this generates the variable arrangement such that there are 2 bytes for the return address instead of 3.

note that in order to return from such a function, you need to use the built-in macro $return

To end the scope, use $}

.TP
.B $< and $>

you can access the variables defined in a function scope using $< and $>

this is an example that adds two numbers and allocates 2000 bytes on the stack just as a test.

the test array is indexed and written to, and the result is written to "b"

.TP
.B ..decl_farproc:add_two_numbers

${(int a, int b)	int[500] test;

	$<a;rx1_0;

	$<b;rxadd;

	lrx1 %/50%; //index to write to in test
	
	$>test;//store the result in the fiftieth entry of test.

	la 3;rx0a; //la la do some stuff
	
	lrx1 %/50%; //get the index again

	$<test;//load from test
	
	$>b;//the caller probably wants their return value in the lowest number
	
	$return
	
$}

Here is another example of the same function that has exactly the same output, but uses

out-of-bounds array accesses to demonstrate memory layout.


.B..decl_farproc:add_two_numbers

${(int a, int b, int[1] secret_array) byte before; int[500] test; int beyond;

$||
#notice how these comments are just fine?

	$<a;rx1_0;
	
	$<b;rxadd;

	lrx1 %/4%;
		
	$>secret_array;#Hi!

	lrx1 %/0%;//hello!

	$<test;
	
	$>b;	$return
$||

$}

.TP
.B $&

Gets the storage address of a local variable in RX0.

$&myLocal;

will cause the address of "myLocal" to be put in RX0.


.TP
.B Exported Symbols

You can set a symbol to be exported to a .hasm.tmp file using a the export command: ..export"myMacro"

You can then put at the bottom of the file:

ASM_EXPORT_HEADER

This can be used to create separate compilation units, such as the "libc" that comes with the emulator.

.TP
.B Syntactic Sugar

There are various extremely common operations in sisa16 that have syntactic sugars available

These Syntactic sugar lines must have nothing else on them, not even comments.
They may have preceding whitespace only! nothing else.

".myMacro:definition"

is syntactic sugar for

VAR#myMacro#definition

this works for conditionals as well:

".?myMacro:definition"

will expand to

"VAR#?myMacro#definition"

":myLabel:"

is syntactic sugar for

asm_label\\myLabel

you can also just use a single colon at the end

"myLabel:"

both of them expand to the same thing.

Note that you CAN put code on the same line as a label definition of these forms, however,

VAR# lines take up the entire line,

so they cannot have any code on them, except of course that which is inside the macro definition.


"..decl_farproc:myProcedure"

is syntactic sugar for

VAR#myProcedure#sc %@%;la region;farcall;

where "region" is not literally placed, but rather the integer associated with the current 64k memory area.

"..decl_farproc(3):myProcedure"

is syntactically identical to above, but "region" will always be 3.
You can also use a macro:

"..decl_farproc(MY_MACRO_EXPANDING_TO_3):myProcedure"

You may not use a builtin macro for this purpose

"..decl_lfarproc:myProcedure"

Will define a macro that calls a procedure in the program counter's current region.

This is useful when you're writing a library that needs to call its own far procedures.

it expands like this:

VAR#myProcedure#cpcr;ac;sc%1000%;farcall;


"..decl_lproc:myProcedure"

is syntactic sugar for

VAR#myProcedure#sc%@%;call;

"..include"file.h"" is syntactic sugar for "ASM_header file.h"

"..dinclude"file.h"" is syntactic sugar for "ASM_data_include file.h"

The following syntactic sugars are allowed to prefix something,
they must be at the beginning of a line, after preceding whitespace:

"..zero:" is syntactic sugar for "section0;"

"..z:" is identical to the above.

"..(37):" is syntactic sugar for "region37;". It selects a region. 

"..ascii:Hello World!" is syntactic sugar for "!Hello World!"

"..asciz:Hello World!" is syntactic sugar for "!Hello World!" followed by a line which says "bytes0", it writes a null-terminated string to the output file.

"..main:" is syntactic sugar for "section0;la1;lfarpc;region1;" it quickly creates a bootloader to region 1. It can be followed immediately by code on the same line.

"..main(X):" is syntactic sugar for selecting region X to be main, and writing a bootloader. It can be followed immediately by code on the same line.

(Note that you shouldn't enter quotes for any of these)

.TP
.B Evaluation Sequence Points (|)

you can use the unix pipe character | to stop the evaluation of macros to a certain point. 
Not only this, but full file writing is done as well, meaning that evaluations of @ between sequence points
results in different values.

Sequence points inside a macro definition line are part of that macro definition.

.TP
.B Headers

ASM_header can be used to include asm files into a program, from the current working directory or /usr/include/sisa16/

.TP
.B Data

ASM_data_include can be used to include raw binary data into the output.


.TP
.B String Literal Lines

string literal lines start with an exclamation mark. Every character after the exclamation mark is part of the string.
the raw characters are written to the output file (ASCII)

.TP
.B Newline Escapes

Most lines can be escaped such that two lines are merged by using \ before the new line.

As mentioned before, you can also use \\//

.TP
.B section

you can move the output counter anywhere in the file using section

//move to to the first non-home region

section 0x10000

.TP
.B region

you can move the output counter to the beginning of a 64k area of memory with region.

region 2

is functionally identical to 

section 0x20000

.TP
.B fill

fill a region with a constant byte value

fill size,val

.TP
.B bytes

write bytes to the output file.

bytes 1,2,3,0xE7,0xA1;

.TP
.B shorts

write shorts to the output file, with high byte first.

shorts 0xFFEE, 0x0011;

is semantically equivalent to...

bytes 0xFF, 0xEE, 0x00, 0x11;

.TP
.B asm_vars

write out all variables (not done with -run) to standard out during assembly

.TP
.B asm_print

print the status of the assembler at the line.


.TP
.B asm_begin_region_restriction

restrict the output counter to the current region and emit an assemblytime error if the output
counter leaves the current region (64k)

.TP
.B asm_begin_block_restriction

the same, but for pages (256 bytes)

.TP
.B asm_end_restriction

End the active restriction.

.TP
.B asm_quit

halt assembly

.TP
.B the single quotes ('')

Used to create character literals.
Multi-character literals are not allowed. Escape codes are provided like C.

.TP
.B the at sign (@)

builtin macro that expands to the current output counter. Is expanded inside of macro
definitions for labels.

You can add an amount to it like this:

@+1+

You can get the region only, by using ampersand after it.

@+1+&

or

@&

You can split it-

%@%

will yield the outputcounter as a byte pair.

.TP
.B SPLIT (%%)

builtin macro to expand a number into a high-low byte pair.

sc %32%;

expands to

sc 0,32;

%256%

expands to

1,0

Splits are NOT evaluated at macro definition time.

if you have defined a variable 

.myVariable:37

and you use it in a split

lla %myVariable%;

then the value will be placed there at macro replacement time.

.TP
.B SPLIT8 (%~%)

builtin macro to evaluate the contained text as an 8 bit number.

This allows forward declaration of an 8 bit constant to be utilized, the same way
you can forward declare a 16/24/32 bit constant and use it with other splits.

la %~5%;

is equvalent to

la 5;

.TP
.B SPLIT32 (%/%)

builtin macro to expand numbers into 4 bytes (highest, high, low, lowest)

lrx0 %/50%;

expands to

lrx0 0,0,0,50;

.TP
.B SPLIT32NEG (%-%)

builtin macro to expand numbers into 4 bytes (highest, high, low, lowest) two's complement.

lrx0 %-1%;

expands to

lrx0 255,255,255,255;

.TP
.B SPLITFLOAT (%?%)

builtin macro to convert floating point numbers into their 32 bit unsigned integer representations.

This is platform-dependent, so it is recommeded to simply embed strings into your binary and use an atof implementation

which utilizes rxitof.

lrx0 %?3.0%;

expands to a platform-specific floating-point conversion of 3.0 to an unsigned integer, as individual bytes.

.TP
.B SPLIT24 (%&%)

builtin macro to convert 32 bit unsigned integers into 24 bit counterparts.

farstrx0 %&0xAEFF00%;

is semantically equivalent to:

farstrx0 0xAE, 0xFF, 0x00;

.TP
.B How the Assembler works

You can get a breakdown of the C assembler's functionality by looking through assembler.c

and going to the main function.

Here's a breakdown.


1. the assembler initializes some variables and handles the commandline arguments, and opens the input file.

	in "normal" operation, it also opens the output file, but...

	if the -run command was used, no output file will be generated, and the memory image will be executed immediately

	after compilation.

2. The assembler starts a pass on the source code...

	Each pass consists of repeatedly fetching lines from the source code and handling them.

3. The assembler fetches a logical line and handles possible newline escapes, repeatedly.

	It also removes preceding whitespace.

4. The assembler attempts to remove comments for the first time.

5. "Syntax sugars" are handled, particularly the lines beginning with two periods, as well as

the single period VAR definition line sugar:

.myVariable:5

If the line was one of these types, it may end up skipping all the way to "end" (the end of the line evaluator).

This means, essentially, that we go immediately to fetching a line again (step 3).

	Note that this is also where the $|| single logical line mode operation is handled.

	note that the single logical line mode operation sets the flag for the NEXT LINE,

	not the CURRENT LINE.

6. After this, special line types are handled, such as the ${ (scope start),  $} (scope end) and ! (string literal)

	Note that some special line types do not produce code and go immediately to the end of the line processing.

7. Header and data includes are handled. Headers work by the assembler keeping an internal "file stack" of FILE pointers,

every new include pushes a pointer onto the stack and the a file ending pops one off the stack.

if a fle ends (at step 3) then the file pointer which included that now-ended file is continued.

8. The assembler tries to remove preceding whitespace from the line again.

9. PRE PRE PROCESSING. All whitespace on the line is changed into normal spaces. The assembler tries to remove comments again.

it then detects if the line was a VAR# line and sets "was_macro".

10. MACRO EXPANSION. All forms of macros are expanded on the line, repeatedly, in a particular order, until there are no macros left on the line.

	NOTE: macro expansion only occurs before the first pipe character (|) on the line.

	I. CHARACTER LITERALS. the first single quote on the line without a backslash in front of it is recognized as the beginning of a character literal.
		if a character literal is recognized, it is then handled, and step 10 repeats.

	II. ASM_GEN_NAME. All instances of ASM_GEN_NAME, regardless of backslashes, are replaced on the line.
		if ASM_GEN_NAME is recognized, It is then handled, and step 10 repeats.

	III. BRACKET BRACKET MACROS. Macros with arguments are parsed. the very first open bracket on the line without a backslash in front of it
	is considered a bracketed macro.
		if a bracketed macro is recognized, it is then handled, and step 10 repeats.

	IV. "ORDINARY" MACROS. user defined macros as well as most of the builtin macros are handled.
		if a macro is recognized, it is then handled, and step 10 repeats.

11. Comments are removed from the line again.

12. VARIABLE DEFINITION. if the line is a VAR# line, a macro is defined by the line, and added to the global list of macros.

	A variable definition line will NOT proceed beyond this step to file writing.

13. All non-space whitespace characters are converted to the single space.

14. INSTRUCTION EXPANSION. If the line contains any instruction names (which, it probably does!) then they are expanded.

the number of arguments passed to it is also checked.

15. FILE WRITING. The "bottom level" commands of the assembler are handled.

	bytes, shorts, section, region, fill, asm_label, asm_print (used for debugging), page/region restriction commands,

	ASM_EXPORT_HEADER,
	
	and asm_halt are handled.

16. SEQUENCE OPERATOR. the sequence operator, the pipe character, is recognized and if it is found on the line, we copy the entire contents

	of the line beyond the sequence operator to the beginning of the line, such that it is as if it is a whole new line.

	if this happened, we go to step 9, PRE PRE PROCESSING again.

17. LINE END. the line is ended. We go and fetch another line from the file (step 3)

18. If there are no more lines in the file, and the file include stack is exhausted, then the pass is finished.

if we have only done one pass, we go and do a second pass.

The two-passes are done to resolve forward references.

Note that the two pass system is also why splits were implemented in the language the way they were-

forward references don't resolve on the first pass (they are not defined yet) however since

the convention of sisa16 assembly is to surround all labels used  by instructions with percent signs, 

and those percent signs indicate how many bytes in size that argument should be,

we can simply write some zeroes in, instead of the proper (and yet unknown!) address.

19. if both passes have been completed, the input and output files are closed, and if the -run argument was used,

the emulator will be used to boot the resulting binary.

~

This pretty much sums up how the SISA16 assembler works.

It is a TODO to port the assembler into SISA16 assembly language. There are various strategies for this-
~~~~~
1) Write a driver (d.h) and modified emulator (isa.c) that 

	implements host filesystem access and commandline argument access, and write an assembler using that.

2) Write an entire operating system for the SISA16 machine, with its own commandline and filesystem and whatnot, and write the assembler for that.


.TP
.B Error handling semantics

if at any point a critical error occurs and the assembler detects it, assembly is aborted.

Unusual or noteworthy phenomenon will be made into warnings, unless on -run

Macro desynchronization between passes (Helpful for recognizing bad labels!) will cause an error, regardless of -run

.TP
.B Undefined and Prohibited behavior

1) You may not put a VAR# definition anywhere other than the beginning of a line.

2) You may not define a macro whose name contains weird characters (nonalpha, not underscore, notnumeric)

3) You may not define a macro which would prevent the use of an instruction.

4) You may not include a file larger than SISA16's address space (16MB)

5) You may not violate an active block (page) or region restriction unless it is disabled or changed.

6) You may not enter a sequence of characters which does not finally resolve into valid commands for the assembler.

7) You may not use an incorrect number of arguments for an instruction.

8) You may not put a comma immediately after an instruction's name.

9) You may not have more than 20 levels of header includes (This is configurable.)

10) You may not define a macro whose name begins with a digit.

11) You may not define a macro beginning with asm_ or ASM_ which are reserved namespacees.

.TP
.B Command and argument Separation
Individual commands are separated with semicolons, and sequence points on the same line are defined with vertical bars.

Arguments to commands are separated with commas, but the first never needs a comma.

la 13;lb 1;add;apush;

is semantically equivalent to

la 13

lb 1

add

apush

but the latter is four separate lines and may assemble slightly slower.

.TP
.B Debugging Assembly


you can pass -E to the assembler to expand all macros.

you can pass -pl to the assembler to print the lines as they're parsed (Sequence points break this somewhat)

if you want more concise debugging, you can use asm_print or asm_vars.

Both asm_print and asm_vars do no checking of their arguments but normal evaluation is done, 
so if you want to have debug values display, it is optimal to make a line:

//a line.

	asm_print 		myMacro;

the line will be printed and you will see this:

asm_print myMacroExpansion;

alongside the original line in the printout.

.TP
.B Debugging programs

A debugger is included which can display registers and memory values during execution. 

it compiles as "sisa16_dbg".

It has its own manpages and its own builtin help.

simply run it with your assembled .bin as its first argument.

type `h` for help.

.TP
.B Platform Semantics

1) SISA16 is big endian. the highest bytes are stored first.

2) the stack pointer grows up.

3) the stack pointer points to the first free byte.

4) The stack pointer is sixteen bit and trapped in the home region, 0x0000 to 0xFFFF.

5) Memory loads wrap around the entire address space- if a load or store would read or write past the edge of memory, it reads or writes to the beginning of memory.

6) Program execution begins at 0. It is best practice to immediately set the A register to some region number
and lfarpc into a main routine as a bootloader.

7) All 16 bit integers are unsigned, but twos complement can be simulated. add subtract multiply all work
with twos complement numbers. To make a number negative, simply take the complement (compl or rxcompl) and add one.

8) when a command refers to the A or B registers, an extra "l" will be included to indicate 16 bit instructions,
otherwise, it is 8 bit. The C register is always 16 bit and no such distinction is made for it.

alpop vs apop, apop works with a single byte on the stack, but alpop loads 2 bytes (big endian).
but there is no clpop, only cpop, which is 16 bit.

9) call and ret work within the same region, if you want to write subroutines across regions, use farcall and farret.

call and ret are more efficient than farcall and farret, though. If you know you're only going to use a function
within a single region, then call/ret is optimal

10) there are no jmpiflt or jmpifgt instructions. use cmp.

//macro to load your value into register A.

ld_value1;

//this will jump to myLabel if value1 is less than 3. cmp returns 0 if a is less than b, 1 if equal, or 2 if greater than.

lb 3;cmp;lb 0;cmp;sc %myLabel%;jmpifeq;

11) Generally, as a convention, the 16 bit registers ABC are used for control flow and memory access, but
RX0-3 are used for 32 bit mathematics.

.TP
.B Privileged Execution

Sisa16 features a rich privilege level system based on memory segmentation.

Yes, I wrote that correctly. The privilege system is based on the memory segmentation scheme.

A SISA16 process has its own sixteen megabytes of memory, which is entirely reserved for it.

It can never have more (except for the segment, which requires copying into and out of memory), 
and it can never have less.

an implementation-defined number of simultaneous processes exists for a particular sisa16 implementation.

A process cannot read or write data outside of its 16 megabytes.

There are two modes of operation: Privileged and non-privileged.

A non-privileged process (also called a task) cannot even address, let alone access, memory that it isn't allowed to.

This makes sisa16's privilege system extremely fast even without a memory mapping unit.
However, this has some notable downsides:

1) User processes are always limited to the 16 megabyte address space they are given, plus their segment. If you only have
one process on a machine, the majority of your memory is essentially wasted (Unless you implement some way to access in your privileged code)

2) 16 megabytes are always reserved exclusively for the privileged code, even if it doesn't need them.

3) If a user process wishes to access more of the system's memory, the privileged process
must provide some means to do this via syscalls/interrupts/etc


Writing a kernel in sisa16 is actually relatively simple. A kernel which provides basic protection of the BIOS device and
disk, simple process management, and interprocess communication is provided in krenel.hasm.

It even provides a small shell if you boot the libc directly. Try it!


.TP
.B Why?

I designed SISA16 originally with the idea of making my own little 8 bit system to futz with. It eventually turned into a huge project,

and the goal became to provide a CPU replacement.

The current implementation is not sufficient for this purpose, though. A proper CPU replacement implementation of SISA16 should be written

in native assembly language for the target hardware, or better yet, implemented in an FPGA.

The SISA16 emulator is a hosted C program.

.TP
.B Design Decisions

~

All opcodes are 1 byte with a fixed number of arguments. This makes parsing and lexing the language easy and it makes

counting the number of bytes in a program easy even just by visual inspection.

~

Local and far memory (2 byte addressing versus 3 byte) came out of the original design of SISA16 being 8 bit- it 

originally had a 16 bit address space. It transitioned over time from being an 8 bit system with a 16 bit address space,

to a 16 bit system with a 16 bit address space, to a 32 bit system with a 24 bit address space.

If I were to write a "new" SISA16-like project, to be a more serious CPU replacement,

I would make it use a flat 24 or 32 bit address space per-process.


~

The multitasking and preemption system of SISA16 was implemented with speed in mind, but still sufficiently flexible

enough to allow detailed scheduling by an operating system implementation.

It went through multiple phases, initially starting out as just "Emulate", 

which copied the entire memory state of the emulator and started executing code with reset registers, which would return

upon the emulated machine encountering an error.

However, this did not actually allow for multitasking or anything, since the new process (and its memory state)

were dead upon returning to the caller and there was no preemption. It was pretty useless.

So I eventually reworked it into the current task-based multitasking model.

A huge part of this design was the memory segmentation model- each process has its own memory, no MMU.

This means that memory accesses do not have to be guarded or trapped.

The Segment is the only memory that the operating system configures MMU-style access to, setting a mask and offset.

~

Generally, I believe SISA16 is pretty secure. There are probably implementation bugs I am not aware of,

but I have tested writing memory out-of-bounds and it didn't.

It is possible for the operating system to incorrectly configure the segment in the emulator,

which can crash the machine if the CPU then tries to read from or write to the segment.

On real hardware, this would probably just read open bus or something like that.

I do not consider this a bug because only privileged code can do this.

Additionally, it is also very likely that my termios and standard drivers are bugged in some fatal way,

but I have yet to discover it.

if there are any ways that a non-privileged process can read or write outside of its address space,

without the privileged process doing it explicitly, then it was certainly not a planned design feature.

~

The syntax of SISA16 assembly language was designed primarily to make it easy to parse, and to make it easy for me,

a C programmer, to write it. Semicolons are for separating commands, not comments, which is an idea from C.

C++ style comments are supported, because I can type them with muscle memory.

Labels were originally only able to be done with VAR#myLabel#@ but support for the double colon syntax

and later the more "standard" single colon syntax were added for convenience.

Macro lines originally started out with VAR# but it was cumbersome to type so I added the period-colon syntax.

I wanted to be able to use characters and strings in my code without resorting to ascii tables, so I 

added those to the language as well.

split syntaxes were added to make turning labels into byte pairs easy and eventually became

the standard way to handle possibly-forward-reference values of any kind.

~
.SH
.B Future plans

Most presently and clearly,

I believe I will pretty soon fill every single opcode in the 256 available.

This saddens me somewhat as I had always seen the large number of available opcodes and thought "Wow! that's a lot!"

At the time of writing, the last instruction I added was farstb.

.SH
.B Writing a real operating system

This system will never be finished in my eyes until I have a commandline and I can self-host the assembler inside the SISA16 VM.

I have already designed a filesystem for this computer architecture and prototyped it in C.

It is a TODO to port the filesystem to KRENEL for use by it and userland processes.

However, once that is finished, I can implement support for it in the standard library and add file pointers,

which is a huge step toward being able to have the assembler self-hosting... which would be the crowning jewel of this project.

Once the assembler is self-hosted and bootstrapped, any person with just the emulator and a .bin for the assembler+OS can write code for the platform.


.SH
.B A C-like programming language

I currently in the process of writing a compiler for a C-like programming language. I have the code generator

for SISA16 partially completed, although I have yet to write the parser at all, so I'm still quite a ways off from having a compiler.

The code generated by it will be very poorly optimized (I'm only planning on writing a stack machine with very simple peephole optimizations,

like turning push-pop pairs into register-to-register moves) but I can accept that.

If I can manage to get a "real" compiled language running on the machine then I can get serious about writing a complete operating system.

Once that happens, the floodgates are open on this architecture. 

If I can have a real human-readable programming language available for SISA16, it would make a huge difference in adoption and usage.

.TP
.B Rewrite for JIT?

I have thought a bit about re-working the architecture to be JIT emulate-able.

Primarily, this means having static unchanging code areas per-process (presumably initialized by a privileged instruction)

the program counter uses, but it also means having a separate out-of-memory stack for return addresses and whatnot,

to prevent arbitrary jumps.

This would require a substantial breaking-change rework and I would have to re-write KRENEL for the new system.

Ultimately, I think I'll never do this. It goes against the spirit of this being a "real" machine and

if it's designed for JIT, it's a glorified JVM.

.TP
.B Real implementation

The emulator is not a real implementation. it does not provide a replacement for the host architecture.

It would be nice if I could get a raspberry pi or something, and port the sisa16 emulator to ARM assembly language with

sisa16 registers mapped to ARM registers.

it would then be possible to have a real box and say that it runs SISA16.

.TP
.B New assembler syntax?

The current assembler syntax requires memorizing every single pnemonic you want to use, or at the very least, the general sense of them.

With the recent addition of farsta and farstb, it should be possible to implement a MOV.

The new assembler would probably be single-pass, properly tokenized, and really just do things more standard than the way 

I wrote the current system.

Using text replacement has its advantages, though...

.TP
.B Multithreading?

This is another one of those 'Pretty much ruins the whole point' deals. If I added multithreading,

I would have to implement a large number of breaking changes, re-write the operating system, 

and it would probably just end up as a glorified JVM.

As for how I'd do it? Probably have multiple sisa16 instances running simultaneously and have some way that they can share a small amount of memory,

maybe send commands in a server-client pattern.

.TP
.B Hosted emulator?

I could probably port Fake6502 to Sisa16 assembly language and have a 6502 emulation mode.

the emulator would obviously have the limitations of the original 6502, however I would be able to use cc65 to write C code for it.

Which means I'd get support for another compiler for free!

Ultimately though, those are not sisa16, and it seems like if I wanted to write an m68k emulator,

I should write it in C.

Most intriguing though is the idea of having SISA16 emulate itself.

the only real use for that which I can think of is to have a debugger on the platform.

.TP
.B LERNEK

Rewrite krenel for the new operating system. I want a cool new name too. Preferably an intentiona misspell, like KRENEL (and KERNAL before it!)

.TP
.B Networking

If (?when) I write a real operating system, i'd like to add features to the termios (or future) driver to add socketed networking support.

.TP
Interesting little language, don't you think?

.SH AUTHOR
David MHS Webster

Email me: davidmhswebster@gmail.com

"Let all your things be done with charity."

To Jesus of Nazareth, the Lord of Lords and King of Kings, be the praise, the might,

the power, the honor, the glory, and the kingdom. For ever. Amen.

.SH LICENSE
For the Public Domain. You (yes you, reader) may use this however you wish.
See CC0 License.
